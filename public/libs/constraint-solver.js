// Generated by CoffeeScript 1.6.2
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

window.ConstraintSolver = (function() {
  function ConstraintSolver() {
    this.constraints = [];
    this.optimizations = [];
    this.variables = {};
    this.iterations = 500;
    this.gradient_step = 0.00005;
    this.debug_mode = true;
    this.compiler = new ConstraintCompiler(this);
  }

  ConstraintSolver.prototype.registerVariable = function(variable) {
    return this.variables[variable.callsign] = variable;
  };

  ConstraintSolver.prototype.registerConstraint = function(constraint) {
    return this.constraints.push(constraint);
  };

  ConstraintSolver.prototype.error = function() {
    var c, error, _i, _len, _ref;

    error = 0;
    _ref = this.constraints;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      error += c.error();
    }
    return error;
  };

  ConstraintSolver.prototype.debug = function(message) {
    if (this.debug_mode) {
      return console.log(message);
    }
  };

  ConstraintSolver.prototype.execute = function(code) {
    return this.compiler.execute(code);
  };

  ConstraintSolver.prototype.solve = function() {
    var c, debug_string, error, i, k, this_error, v, variable_gradients, _i, _j, _len, _ref, _ref1, _ref2, _ref3;

    this.debug("Beginning constraint solver under " + this.constraints.length + " constraints and " + this.variables.length + " variables.");
    for (i = _i = 1, _ref = this.iterations; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      error = this.error();
      this.debug("Beginning iteration " + i + ", current error value = " + error);
      variable_gradients = {};
      _ref1 = this.variables;
      for (k in _ref1) {
        v = _ref1[k];
        variable_gradients[k] = 0;
      }
      _ref2 = this.constraints;
      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
        c = _ref2[_j];
        for (k in variable_gradients) {
          v = variable_gradients[k];
          this_error = this.variables[k].determineErrorGradientWithRespectToConstraint.call(this.variables[k], c);
          variable_gradients[k] += this_error;
          console.log("The error on " + this.variables[k].callsign + " found was: " + this_error);
        }
      }
      _ref3 = this.variables;
      for (k in _ref3) {
        v = _ref3[k];
        debug_string = "Increment " + v.callsign + " from " + v.value + " ->";
        v.assign(v.seed + variable_gradients[k] * this.gradient_step);
        console.log(debug_string, "" + v.value);
      }
    }
    return this.variables;
  };

  return ConstraintSolver;

})();

window.GenericVariable = (function() {
  function GenericVariable() {
    var _ref, _ref1, _ref2, _ref3;

    if ((_ref = this.value) == null) {
      this.value = this.assign(Math.random());
    }
    if ((_ref1 = this.callsign) == null) {
      this.callsign = "_dump";
    }
    if ((_ref2 = this.parent) == null) {
      this.parent = null;
    }
    if ((_ref3 = this.error_gradient_step) == null) {
      this.error_gradient_step = 0.001;
    }
  }

  GenericVariable.prototype.generator = function(seed) {
    throw "Can't generate with a GenericVariable";
  };

  GenericVariable.prototype.assign = function(seed) {
    this.seed = seed;
    this.value = this.generator(this.seed);
    return window[this.callsign] = this.value;
  };

  GenericVariable.prototype.registerWithParent = function(parent) {
    this.parent = parent;
    return true;
  };

  GenericVariable.prototype.determineErrorGradientWithRespectToConstraint = function(constraint) {
    var left_error, right_error;

    window[this.callsign] = this.generator(this.seed - 0.5 * this.error_gradient_step);
    left_error = constraint.error();
    window[this.callsign] = this.generator(this.seed + 0.5 * this.error_gradient_step);
    right_error = constraint.error();
    window[this.callsign] = this.value;
    return -1.0 * (right_error - left_error) / this.error_gradient_step;
  };

  return GenericVariable;

})();

window.UniformRangeVariable = (function(_super) {
  __extends(UniformRangeVariable, _super);

  function UniformRangeVariable(callsign, lower_limit, upper_limit) {
    var _ref;

    this.callsign = callsign;
    this.lower_limit = lower_limit;
    this.upper_limit = upper_limit;
    if (this.lower_limit > this.upper_limit) {
      _ref = [this.upper_limit, this.lower_limit], this.lower_limit = _ref[0], this.upper_limit = _ref[1];
    }
    UniformRangeVariable.__super__.constructor.call(this);
  }

  UniformRangeVariable.prototype.generator = function(seed) {
    if (seed > 1) {
      seed = 1;
    } else if (seed < 0) {
      seed = 0;
    }
    return this.lower_limit + (this.upper_limit - this.lower_limit) * seed;
  };

  return UniformRangeVariable;

})(GenericVariable);

window.Constraint = (function() {
  function Constraint(left_hand_expression, right_hand_expression, tolerance) {
    this.left_hand_expression = left_hand_expression;
    this.right_hand_expression = right_hand_expression;
    this.tolerance = tolerance != null ? tolerance : 0.01;
    this.validate();
  }

  Constraint.prototype.evaluate = function() {
    var LHS, RHS;

    LHS = eval(this.left_hand_expression);
    RHS = eval(this.right_hand_expression);
    if (Math.abs(LHS - RHS) < this.tolerance) {
      return true;
    } else {
      return false;
    }
  };

  Constraint.prototype.error = function() {
    var LHS, RHS;

    LHS = eval(this.left_hand_expression);
    RHS = eval(this.right_hand_expression);
    return Math.pow(Math.abs(LHS - RHS), 2);
  };

  Constraint.prototype.validate = function() {
    var error;

    try {
      eval(this.left_hand_expression);
      return eval(this.right_hand_expression);
    } catch (_error) {
      error = _error;
      throw "Invalid constraint expression: " + error;
    }
  };

  return Constraint;

})();

window.ConstraintCompiler = (function() {
  function ConstraintCompiler(parent) {
    this.parent = parent;
    true;
  }

  ConstraintCompiler.prototype.execute = function(code) {
    var components, left_side, line, lines, lower_bound, remaining_string, right_side, upper_bound, words, _i, _len, _results;

    code = code.replace(/[\r]/gm, "");
    lines = code.split(/\n/);
    _results = [];
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      words = line.split(/\s+/);
      switch (words[0]) {
        case ":variable":
          assert(words[2] === "between", ":variable statement must include 'between' clause");
          assert(words[4] === "and", ":variable statement must include 'and' subclause in 'between' clause");
          assert(words.length === 6, "Invalid number of arguments for :variable, expected 4");
          lower_bound = parseFloat(words[3]);
          upper_bound = parseFloat(words[5]);
          _results.push(this.parent.registerVariable(new UniformRangeVariable(words[1], lower_bound, upper_bound)));
          break;
        case ":constraint":
          remaining_string = words.slice(1).join(' ');
          components = remaining_string.split(/\=/);
          assert(components.length === 2, "Invalid constraint statement.");
          left_side = components[0];
          right_side = components[1];
          _results.push(this.parent.registerConstraint(new Constraint(left_side, right_side)));
          break;
        case ":solve":
          assert(words.length === 1, "Invalid 'solve' statement, unexpected extra clause");
          _results.push(this.parent.solve());
          break;
        default:
          throw "Unrecognized command " + words[0] + ".";
      }
    }
    return _results;
  };

  return ConstraintCompiler;

})();
